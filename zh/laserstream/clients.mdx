---
title: LaserStream 客户端
sidebarTitle: 客户端
description: 高性能 SDK，用于 gRPC 流媒体，具有自动重播和零数据丢失功能
---

## 断开连接时自动重播

LaserStream 客户端通过槽号持续跟踪您的流媒体位置。如果发生断开连接——无论是由于网络问题、服务器维护还是其他原因——客户端会自动重新连接并从您上次处理的槽位恢复流媒体。您永远不会丢失数据，永远不会错过交易，也不需要编写重新连接逻辑。

## JavaScript/TypeScript 客户端

[JavaScript 客户端](https://github.com/helius-labs/laserstream-sdk/tree/main/javascript) 使用原生 Rust 绑定实现 1.3GB/s 的吞吐量——比 Yellowstone gRPC JavaScript 客户端快 40 倍以上，后者的最大吞吐量为 30MB/s。

<Warning>
随着 Solana 的持续扩展，Yellowstone JavaScript 客户端将难以跟上。如果 Solana 提速 3 倍，订阅所有交易或区块的 Yellowstone gRPC 客户端将无法匹配链速度。LaserStream 客户端的性能余量确保您的应用程序能够随网络扩展。
</Warning>

在高带宽订阅中，Yellowstone 客户端会经历随时间累积的渐进延迟。LaserStream 无论数据量如何，始终保持一致的低延迟流媒体。

### 安装

<CodeGroup>

```bash npm
npm install helius-laserstream
```

```bash yarn
yarn add helius-laserstream
```

```bash pnpm
pnpm add helius-laserstream
```

</CodeGroup>

### 快速开始

```typescript [expandable]
import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream';

async function streamTransactions() {
  const config: LaserstreamConfig = {
    apiKey: 'YOUR_API_KEY',
    endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com',
  };

  const request: SubscribeRequest = {
    transactions: {
      client: {
        accountInclude: ['JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4'], // Jupiter Program
        accountExclude: [],
        accountRequired: [],
        vote: false,
        failed: false
      }
    },
    commitment: CommitmentLevel.CONFIRMED,
    accounts: {},
    slots: {},
    transactionsStatus: {},
    blocks: {},
    blocksMeta: {},
    entry: {},
    accountsDataSlice: []
  };

  // The SDK handles reconnection and replay automatically
  await subscribe(config, request, 
    async (data) => {
      console.log('New transaction:', data);
    }, 
    async (error) => {
      console.error('Error:', error);
    }
  );
}

streamTransactions().catch(console.error);
```

### 可靠性比较

| 功能 | LaserStream | Yellowstone |
|---------|------------|-------------|
| 自动重播 | ✅ 内置 | ❌ 需要手动实现 |
| 渐进延迟 | ❌ 无 | ✅ 在高带宽下 |
| 数据丢失保护 | ✅ 自动 | ❌ 应用程序负责 |
| 重新连接 | ✅ 无缝 | ❌ 无内置支持 |

## Rust 客户端

[Rust 客户端](https://github.com/helius-labs/laserstream-sdk/tree/main/rust) 提供零拷贝反序列化和原生性能，适用于需要最大控制的应用程序。

### 安装

```toml
[dependencies]
helius-laserstream = "0.1"
tokio = { version = "1", features = ["full"] }
```

### 快速开始

```rust [expandable]
use helius_laserstream::{subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest};
use futures::StreamExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = LaserstreamConfig {
        api_key: "YOUR_API_KEY".to_string(),
        endpoint: "https://laserstream-mainnet-ewr.helius-rpc.com".to_string(),
    };

    let request = SubscribeRequest {
        transactions: Some(TransactionsFilter {
            client: Some(TransactionFilter {
                account_include: vec!["JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4".to_string()],
                vote: false,
                failed: false,
                ..Default::default()
            }),
        }),
        commitment: CommitmentLevel::Confirmed,
        ..Default::default()
    };

    let mut stream = subscribe(config, request).await?;

    while let Some(result) = stream.next().await {
        match result {
            Ok(data) => println!("New transaction: {:?}", data),
            Err(e) => eprintln!("Error: {:?}", e),
        }
    }

    Ok(())
}
```

## Go 客户端

[Go 客户端](https://github.com/helius-labs/laserstream-sdk/tree/main/go) 提供惯用的 Go 接口。

### 安装

```bash
go get github.com/helius-labs/laserstream-sdk/go
```

### 快速开始

```go [expandable]
package main

import (
    "context"
    "fmt"
    "log"
    
    laserstream "github.com/helius-labs/laserstream-sdk/go"
)

func main() {
    config := &laserstream.Config{
        APIKey:   "YOUR_API_KEY",
        Endpoint: "https://laserstream-mainnet-ewr.helius-rpc.com",
    }

    request := &laserstream.SubscribeRequest{
        Transactions: &laserstream.TransactionsFilter{
            Client: &laserstream.TransactionFilter{
                AccountInclude: []string{"JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4"},
                Vote:          false,
                Failed:        false,
            },
        },
        Commitment: laserstream.CommitmentConfirmed,
    }

    ctx := context.Background()
    stream, err := laserstream.Subscribe(ctx, config, request)
    if err != nil {
        log.Fatal(err)
    }

    for data := range stream {
        if data.Error != nil {
            log.Printf("Error: %v", data.Error)
            continue
        }
        fmt.Printf("New transaction: %+v\n", data)
    }
}
```

## 为什么从 Yellowstone 迁移到 LaserStream

Yellowstone 客户端面临的关键限制将随着 Solana 的扩展而恶化：

1. **性能瓶颈**：Yellowstone JavaScript 客户端的最大吞吐量为 30MB/s——对于高吞吐量应用程序来说不够
2. **渐进延迟**：在高带宽订阅中，延迟会随着时间的推移而累积
3. **手动重播**：您必须实现自己的重新连接和重播逻辑
4. **数据丢失风险**：没有内置重播，网络中断意味着错过交易

**LaserStream 解决了这些问题**。通过 40 倍的性能提升、自动重播和零数据丢失保证，迁移到 LaserStream 确保您的应用程序在 Solana 发展过程中保持竞争力。
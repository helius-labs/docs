---
title: Solana Yellowstone gRPC å¿«é€Ÿå…¥é—¨ï¼šå®æ—¶æ•°æ®æµ
sidebarTitle: å¿«é€Ÿå…¥é—¨
description: å®Œæ•´çš„è®¾ç½®æŒ‡å—ï¼Œç”¨äºé€šè¿‡ Yellowstone gRPC æµå¼ä¼ è¾“å®æ—¶ Solana æ•°æ®ã€‚ä»å®‰è£…åˆ°æ‚¨çš„ç¬¬ä¸€ä¸ªå·¥ä½œæµï¼Œæ”¯æŒè‡ªåŠ¨é‡æ–°è¿æ¥ã€‚
---

## æ‚¨å°†æ„å»ºä»€ä¹ˆ

åœ¨æœ¬æŒ‡å—ç»“æŸæ—¶ï¼Œæ‚¨å°†æ‹¥æœ‰ä¸€ä¸ªå·¥ä½œä¸­çš„ gRPC æµï¼Œå¯ä»¥å®æ—¶ç›‘æ§ Solana è´¦æˆ·æ›´æ–°ï¼Œå¹¶å…·æœ‰è‡ªåŠ¨é‡æ–°è¿æ¥å’Œé”™è¯¯å¤„ç†åŠŸèƒ½ã€‚

<Steps>
  <Step title="é€‰æ‹©æ‚¨çš„è®¿é—®æ–¹æ³•">
    é€‰æ‹©æ‚¨å¸Œæœ›å¦‚ä½•è®¿é—® Yellowstone gRPCï¼š
    
    <CardGroup cols={2}>
      <Card title="LaserStream" icon="rocket">
        **æ¨èç»™å¤§å¤šæ•°ç”¨æˆ·**
        
        - å¤šç§Ÿæˆ·ï¼Œé«˜å¯ç”¨æ€§
        - è‡ªåŠ¨æ•…éšœè½¬ç§»å’Œå›å¡«
        - ä½¿ç”¨ API å¯†é’¥å¿«é€Ÿè®¾ç½®
        - éœ€è¦ Developer+ è®¡åˆ’ï¼ˆdevnetï¼‰ï¼ŒProfessional+ï¼ˆmainnetï¼‰
        
        [è·å– LaserStream è®¿é—®æƒé™ â†’](/laserstream/)
      </Card>
      <Card title="ä¸“ç”¨èŠ‚ç‚¹" icon="server">
        **é€‚ç”¨äºé«˜æµé‡æˆ–è‡ªå®šä¹‰éœ€æ±‚**
        
        - ç‹¬å  gRPC ç«¯ç‚¹  
        - ä¿è¯èµ„æº
        
        [è·å–ä¸“ç”¨èŠ‚ç‚¹ â†’](/dedicated-nodes/)
      </Card>
    </CardGroup>
  </Step>

  <Step title="è®¾ç½®æ‚¨çš„ç¯å¢ƒ">
    åˆ›å»ºä¸€ä¸ªæ–°é¡¹ç›®å¹¶å®‰è£…ä¾èµ–é¡¹ï¼š

    <Tabs>
      <Tab title="TypeScript/JavaScript">

        ```bash
        mkdir solana-grpc-stream
        cd solana-grpc-stream
        npm init -y
        npm install @triton-one/yellowstone-grpc bs58
        npm install typescript ts-node @types/node --save-dev
        npx tsc --init
        ```

      </Tab>
      
      <Tab title="Rust">

        ```bash
        cargo new solana-grpc-stream
        cd solana-grpc-stream
        ```

        
        æ·»åŠ åˆ° `Cargo.toml`:

        ```toml
        [dependencies]
        yellowstone-grpc-client = "1.13.0"
        yellowstone-grpc-proto = "1.13.0"
        tokio = { version = "1.0", features = ["full"] }
        anyhow = "1.0"
        futures = "0.3"
        tonic = "0.10"
        ```

      </Tab>
      
      <Tab title="Go">

        ```bash
        mkdir solana-grpc-stream
        cd solana-grpc-stream
        go mod init solana-grpc-stream
        go get github.com/rpcpool/yellowstone-grpc/examples/golang@latest
        go get google.golang.org/grpc@v1.67.1
        ```

      </Tab>
    </Tabs>
  </Step>

  <Step title="è·å–æ‚¨çš„å‡­æ®">
    è·å–æ‚¨çš„ gRPC ç«¯ç‚¹å’Œèº«ä»½éªŒè¯ä¿¡æ¯ï¼š

    <Tabs>
      <Tab title="LaserStream">
        1. åœ¨ [dashboard.helius.dev](https://dashboard.helius.dev) æ³¨å†Œ Developer+ è®¡åˆ’ï¼ˆdevnetï¼‰æˆ– Professional è®¡åˆ’ï¼ˆmainnetï¼‰
        2. ä»ä»ªè¡¨æ¿è·å–æ‚¨çš„ API å¯†é’¥
        3. é€‰æ‹©æ‚¨çš„åŒºåŸŸç«¯ç‚¹ï¼š
        
        **Mainnet ç«¯ç‚¹ï¼š**
        - ç¾å›½ä¸œéƒ¨ï¼š`https://laserstream-mainnet-ewr.helius-rpc.com`
        - ç¾å›½è¥¿éƒ¨ï¼š`https://laserstream-mainnet-slc.helius-rpc.com`
        - æ¬§æ´²ï¼š`https://laserstream-mainnet-fra.helius-rpc.com`
        - äºšæ´²ï¼š`https://laserstream-mainnet-tyo.helius-rpc.com`
        
        **Devnetï¼š** `https://laserstream-devnet-ewr.helius-rpc.com`
      </Tab>
      
      <Tab title="ä¸“ç”¨èŠ‚ç‚¹">
        1. ä» [dashboard.helius.dev](https://dashboard.helius.dev/dedicated-nodes) è®¢è´­ä¸“ç”¨èŠ‚ç‚¹
        2. ä¸€æ—¦é…ç½®å®Œæˆï¼Œæ‚¨å°†æ”¶åˆ°ï¼š
           - æ‚¨çš„ gRPC ç«¯ç‚¹ï¼ˆé€šå¸¸ä¸º `your-node.rpc.helius.dev:2053`ï¼‰
           - æ‚¨çš„èº«ä»½éªŒè¯ä»¤ç‰Œ
      </Tab>
    </Tabs>
  </Step>

  <Step title="åˆ›å»ºæ‚¨çš„ç¬¬ä¸€ä¸ªæµ">
    ä½¿ç”¨ä»¥ä¸‹å®Œæ•´ç¤ºä¾‹åˆ›å»ºä¸€ä¸ªå¼ºå¤§çš„æµç®¡ç†å™¨ï¼š

    <Tabs>
      <Tab title="TypeScript">
        åˆ›å»º `stream-manager.ts`:
        

        ```typescript
        import Client, { CommitmentLevel, SubscribeRequest } from "@triton-one/yellowstone-grpc";
        import * as bs58 from 'bs58';

        export class StreamManager {
          private client: Client;
          private stream: any;
          private isConnected = false;
          private reconnectAttempts = 0;
          private readonly maxReconnectAttempts = 10;
          private readonly baseReconnectDelay = 1000; // 1 second

          constructor(
            private endpoint: string,
            private apiKey: string,
            private onData: (data: any) => void,
            private onError?: (error: any) => void
          ) {
            this.client = new Client(endpoint, apiKey, {
              "grpc.max_receive_message_length": 64 * 1024 * 1024
            });
          }

          async connect(subscribeRequest: SubscribeRequest): Promise<void> {
            try {
              console.log(`Connecting to ${this.endpoint}...`);
              this.stream = await this.client.subscribe();
              this.isConnected = true;
              this.reconnectAttempts = 0;

              // Set up event handlers
              this.stream.on("data", this.handleData.bind(this));
              this.stream.on("error", this.handleStreamError.bind(this));
              this.stream.on("end", () => this.handleDisconnect(subscribeRequest));
              this.stream.on("close", () => this.handleDisconnect(subscribeRequest));

              // Send subscription request
              await this.writeRequest(subscribeRequest);
              
              // Start keepalive
              this.startKeepalive();
              
              console.log("âœ… Connected and subscribed successfully");
            } catch (error) {
              console.error("Connection failed:", error);
              await this.reconnect(subscribeRequest);
            }
          }

          private async writeRequest(request: SubscribeRequest): Promise<void> {
            return new Promise((resolve, reject) => {
              this.stream.write(request, (err: any) => {
                if (err) reject(err);
                else resolve();
              });
            });
          }

          private handleData(data: any): void {
            try {
              // Convert buffers to readable format
              const processedData = this.processBuffers(data);
              this.onData(processedData);
            } catch (error) {
              console.error("Error processing data:", error);
            }
          }

          private processBuffers(obj: any): any {
            if (!obj) return obj;
            
            if (Buffer.isBuffer(obj) || obj instanceof Uint8Array) {
              return bs58.default.encode(obj);
            }
            
            if (Array.isArray(obj)) {
              return obj.map(item => this.processBuffers(item));
            }
            
            if (typeof obj === 'object') {
              return Object.fromEntries(
                Object.entries(obj).map(([k, v]) => [k, this.processBuffers(v)])
              );
            }
            
            return obj;
          }

          private handleStreamError(error: any): void {
            console.error("Stream error:", error);
            this.isConnected = false;
            if (this.onError) this.onError(error);
          }

          private async handleDisconnect(subscribeRequest: SubscribeRequest): Promise<void> {
            if (this.isConnected) {
              console.log("Stream disconnected, attempting to reconnect...");
              this.isConnected = false;
              await this.reconnect(subscribeRequest);
            }
          }

          private async reconnect(subscribeRequest: SubscribeRequest): Promise<void> {
            if (this.reconnectAttempts >= this.maxReconnectAttempts) {
              console.error("Max reconnection attempts reached. Giving up.");
              return;
            }

            this.reconnectAttempts++;
            const delay = this.baseReconnectDelay * Math.pow(2, Math.min(this.reconnectAttempts - 1, 5));
            
            console.log(`Reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${delay}ms...`);
            
            setTimeout(() => {
              this.connect(subscribeRequest).catch(console.error);
            }, delay);
          }

          private startKeepalive(): void {
            setInterval(() => {
              if (this.isConnected) {
                const pingRequest: SubscribeRequest = {
                  ping: { id: Date.now() },
                  accounts: {},
                  accountsDataSlice: [],
                  transactions: {},
                  slots: {},
                  blocks: {},
                  blocksMeta: {},
                  entry: {},
                  transactionsStatus: {}
                };
                
                this.writeRequest(pingRequest).catch(console.error);
              }
            }, 30000); // 30 seconds
          }

          disconnect(): void {
            if (this.stream) {
              this.stream.end();
            }
            this.client.close();
            this.isConnected = false;
          }
        }
        ```

        åˆ›å»º `main.ts`:
        

        ```typescript
        import { StreamManager } from './stream-manager';
        import { CommitmentLevel, SubscribeRequest } from "@triton-one/yellowstone-grpc";

        // Configuration
        const ENDPOINT = "your-grpc-endpoint"; // LaserStream or Dedicated Node endpoint
        const API_KEY = "your-api-key";

        // USDC Token Mint for example
        const USDC_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

        async function main() {
          const streamManager = new StreamManager(
            ENDPOINT,
            API_KEY,
            handleAccountUpdate,
            handleError
          );

          // Subscribe to USDC mint account updates
          const subscribeRequest: SubscribeRequest = {
            accounts: {
              accountSubscribe: {
                account: [USDC_MINT],
                owner: [],
                filters: []
              }
            },
            accountsDataSlice: [],
            commitment: CommitmentLevel.CONFIRMED,
            slots: {},
            transactions: {},
            transactionsStatus: {},
            blocks: {},
            blocksMeta: {},
            entry: {}
          };

          console.log("ğŸš€ Starting USDC mint account monitoring...");
          await streamManager.connect(subscribeRequest);

          // Handle graceful shutdown
          process.on('SIGINT', () => {
            console.log('\nğŸ›‘ Shutting down...');
            streamManager.disconnect();
            process.exit(0);
          });
        }

        function handleAccountUpdate(data: any): void {
          if (data.account) {
            const account = data.account.account;
            console.log('\nğŸ“Š Account Update:');
            console.log(`  Account: ${account.pubkey}`);
            console.log(`  Owner: ${account.owner}`);
            console.log(`  Lamports: ${account.lamports}`);
            console.log(`  Data Length: ${account.data?.length || 0} bytes`);
            console.log(`  Slot: ${data.account.slot}`);
            console.log(`  Timestamp: ${new Date().toISOString()}`);
          }
          
          if (data.pong) {
            console.log(`ğŸ’“ Keepalive pong received (id: ${data.pong.id})`);
          }
        }

        function handleError(error: any): void {
          console.error('âŒ Stream error:', error.message);
        }

        main().catch(console.error);
        ```

        
        è¿è¡Œä½ çš„æµï¼š

        ```bash
        npx ts-node main.ts
        ```

      </Tab>
      
      <Tab title="Rust">
        åˆ›å»º `src/main.rs`:
        

        ```rust
        use yellowstone_grpc_client::GeyserGrpcClient;
        use yellowstone_grpc_proto::prelude::*;
        use futures::StreamExt;
        use std::collections::HashMap;
        use tokio::time::{sleep, Duration};

        #[tokio::main]
        async fn main() -> anyhow::Result<()> {
            let endpoint = "your-grpc-endpoint"; // Replace with your endpoint
            let token = Some("your-api-key".to_string()); // Replace with your API key
            
            let mut client = GeyserGrpcClient::connect(endpoint, token, None).await?;
            
            // USDC mint account
            let usdc_mint = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
            
            let mut accounts = HashMap::new();
            accounts.insert(
                "usdc_mint".to_string(),
                SubscribeRequestFilterAccounts {
                    account: vec![usdc_mint.to_string()],
                    owner: vec![],
                    filters: vec![],
                }
            );
            
            let mut stream = client.subscribe_once(
                accounts,
                HashMap::new(), // slots
                HashMap::new(), // transactions
                HashMap::new(), // blocks
                HashMap::new(), // blocks_meta
                None, // commitment
                HashMap::new(), // accounts_data_slice
                Some(CommitmentLevel::Confirmed),
                HashMap::new(), // entry
            ).await?;

            println!("ğŸš€ Connected! Monitoring USDC mint account...");
            
            while let Some(message) = stream.next().await {
                match message {
                    Ok(msg) => {
                        if let Some(account) = msg.update_oneof {
                            match account {
                                subscribe_update::UpdateOneof::Account(account_update) => {
                                    println!("\nğŸ“Š Account Update:");
                                    println!("  Account: {}", account_update.account.as_ref()
                                        .map(|a| &a.pubkey).unwrap_or(&"N/A".to_string()));
                                    println!("  Lamports: {}", account_update.account.as_ref()
                                        .map(|a| a.lamports).unwrap_or(0));
                                    println!("  Slot: {}", account_update.slot);
                                }
                                _ => {} // Handle other update types as needed
                            }
                        }
                    }
                    Err(error) => {
                        eprintln!("âŒ Stream error: {}", error);
                        sleep(Duration::from_secs(1)).await;
                    }
                }
            }
            
            Ok(())
        }
        ```

        
        è¿è¡Œä½ çš„æµï¼š

        ```bash
        cargo run
        ```

      </Tab>
      
      <Tab title="Go">
        åˆ›å»º `main.go`:
        

        ```go
        package main

        import (
            "context"
            "fmt"
            "log"
            "time"

            "github.com/rpcpool/yellowstone-grpc/examples/golang/pkg/grpc"
            pb "github.com/rpcpool/yellowstone-grpc/examples/golang/pkg/proto"
            "google.golang.org/grpc/metadata"
        )

        func main() {
            endpoint := "your-grpc-endpoint" // Replace with your endpoint
            apiKey := "your-api-key"         // Replace with your API key
            
            client, err := grpc.NewGrpcConnection(context.Background(), endpoint)
            if err != nil {
                log.Fatalf("Failed to connect: %v", err)
            }
            defer client.Close()
            
            // Add authentication
            ctx := metadata.AppendToOutgoingContext(context.Background(), "x-token", apiKey)
            
            // USDC mint account
            usdcMint := "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
            
            stream, err := client.Subscribe(ctx)
            if err != nil {
                log.Fatalf("Failed to subscribe: %v", err)
            }
            
            // Send subscription request
            request := &pb.SubscribeRequest{
                Accounts: map[string]*pb.SubscribeRequestFilterAccounts{
                    "usdc_mint": {
                        Account: []string{usdcMint},
                        Owner:   []string{},
                        Filters: []*pb.SubscribeRequestFilterAccountsFilter{},
                    },
                },
                Commitment: pb.CommitmentLevel_CONFIRMED,
            }
            
            if err := stream.Send(request); err != nil {
                log.Fatalf("Failed to send request: %v", err)
            }
            
            fmt.Println("ğŸš€ Connected! Monitoring USDC mint account...")
            
            for {
                response, err := stream.Recv()
                if err != nil {
                    log.Printf("âŒ Stream error: %v", err)
                    time.Sleep(time.Second)
                    continue
                }
                
                if account := response.GetAccount(); account != nil {
                    fmt.Printf("\nğŸ“Š Account Update:\n")
                    fmt.Printf("  Account: %s\n", account.Account.Pubkey)
                    fmt.Printf("  Lamports: %d\n", account.Account.Lamports)
                    fmt.Printf("  Slot: %d\n", account.Slot)
                    fmt.Printf("  Timestamp: %s\n", time.Now().Format(time.RFC3339))
                }
            }
        }
        ```

        
        è¿è¡Œä½ çš„æµï¼š

        ```bash
        go run main.go
        ```

      </Tab>
    </Tabs>
  </Step>

  <Step title="æµ‹è¯•ä½ çš„æµ">
    è¿è¡Œä½ çš„åº”ç”¨ç¨‹åºå¹¶éªŒè¯å…¶å·¥ä½œï¼š

    1. **å¯åŠ¨ä½ çš„æµ** ä½¿ç”¨é€‚åˆä½ çš„è¯­è¨€çš„å‘½ä»¤
    2. **åœ¨æ§åˆ¶å°ä¸­æŸ¥æ‰¾è¿æ¥ç¡®è®¤**
    3. **ç­‰å¾…è´¦æˆ·æ›´æ–°** - ä½ åº”è¯¥ä¼šçœ‹åˆ°USDCé“¸å¸è´¦æˆ·çš„å®šæœŸæ›´æ–°
    4. **æµ‹è¯•é‡æ–°è¿æ¥** é€šè¿‡æš‚æ—¶æ–­å¼€äº’è”ç½‘è¿æ¥
    5. **éªŒè¯ä¿æ´»** é€šè¿‡æ¯30ç§’è§‚å¯Ÿä¸€æ¬¡pongæ¶ˆæ¯

    **é¢„æœŸè¾“å‡ºï¼š**

    ```
    ğŸš€ Connected! Monitoring USDC mint account...
    âœ… Connected and subscribed successfully
    ğŸ’“ Keepalive pong received (id: 1703123456789)
    
    ğŸ“Š Account Update:
      Account: EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
      Owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
      Lamports: 1461600
      Data Length: 82 bytes
      Slot: 275123456
      Timestamp: 2024-01-15T10:30:45.123Z
    ```

  </Step>
</Steps>

## æ¥ä¸‹æ¥æ˜¯ä»€ä¹ˆï¼Ÿ

ç°åœ¨ä½ æœ‰äº†ä¸€ä¸ªå·¥ä½œçš„gRPCæµï¼Œæ¢ç´¢è¿™äº›ç›‘æ§æŒ‡å—ï¼š

<CardGroup cols={2}>
  <Card title="è´¦æˆ·ç›‘æ§" icon="user" href="/grpc/account-monitoring">
    é«˜çº§è´¦æˆ·è¿‡æ»¤å’Œæ•°æ®åˆ‡ç‰‡æŠ€æœ¯
  </Card>
  <Card title="äº¤æ˜“ç›‘æ§" icon="receipt" href="/grpc/transaction-monitoring">
    ä½¿ç”¨ç¨‹åºè¿‡æ»¤å’Œæ‰§è¡Œç»†èŠ‚çš„æµäº¤æ˜“
  </Card>
  <Card title="æ§½ä½å’ŒåŒºå—ç›‘æ§" icon="cube" href="/grpc/slot-and-block-monitoring">
    ç›‘æ§ç½‘ç»œå…±è¯†å’ŒåŒºå—ç”Ÿäº§
  </Card>
  <Card title="æµæ³µAMMæ•°æ®" icon="chart-line" href="/grpc/stream-pump-amm-data">
    çœŸå®ä¸–ç•Œç¤ºä¾‹ï¼šç›‘æ§DeFiåè®®æ•°æ®
  </Card>
</CardGroup>

## æ•…éšœæ’é™¤

<Accordion title="è¿æ¥é—®é¢˜">
  **ç—‡çŠ¶ï¼š** è¿æ¥è¶…æ—¶ï¼Œèº«ä»½éªŒè¯é”™è¯¯
  
  **è§£å†³æ–¹æ¡ˆï¼š**
  - éªŒè¯ä½ çš„ç«¯ç‚¹URLå’ŒAPIå¯†é’¥
  - æ£€æŸ¥ä½ çš„è®¡åˆ’æ˜¯å¦åŒ…æ‹¬gRPCè®¿é—®
  - ç¡®ä¿ä½ ä½¿ç”¨çš„æ˜¯æ­£ç¡®çš„ç«¯å£ï¼ˆé€šå¸¸ä¸ºä¸“ç”¨èŠ‚ç‚¹çš„2053ï¼‰
  - å¯¹äºLaserStreamï¼Œç¡®ä¿ä½ è‡³å°‘æœ‰å¼€å‘è€…è®¡åˆ’ï¼ˆdevnetï¼‰æˆ–ä¸“ä¸šè®¡åˆ’ï¼ˆmainnetï¼‰
</Accordion>

<Accordion title="æœªæ¥æ”¶åˆ°æ•°æ®">
  **ç—‡çŠ¶ï¼š** æµè¿æ¥æˆåŠŸä½†æ²¡æœ‰è´¦æˆ·æ›´æ–°å‡ºç°
  
  **è§£å†³æ–¹æ¡ˆï¼š**
  - USDC é“¸å¸æ›´æ–°ä¸é¢‘ç¹ - å°è¯•ç›‘æ§ä¸€ä¸ªæ›´æ´»è·ƒçš„è´¦æˆ·
  - æ£€æŸ¥æ‚¨çš„æ‰¿è¯ºçº§åˆ«ï¼ˆå°è¯• `PROCESSED` ä»¥è·å–æ›´é¢‘ç¹çš„æ›´æ–°ï¼‰
  - éªŒè¯æ‚¨çš„è´¦æˆ·è¿‡æ»¤å™¨é…ç½®
  - ç›‘æ§ä¸€ä¸ªä»£å¸è´¦æˆ·è€Œä¸æ˜¯é“¸å¸ä»¥è·å¾—æ›´å¤šæ´»åŠ¨
</Accordion>

<Accordion title="æµæ–­å¼€è¿æ¥">
  **ç—‡çŠ¶ï¼š** é¢‘ç¹æ–­å¼€è¿æ¥ï¼Œé‡æ–°è¿æ¥å¾ªç¯
  
  **è§£å†³æ–¹æ¡ˆï¼š**
  - å®ç°æŒ‡æ•°é€€é¿ï¼ˆåŒ…å«åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼‰
  - æ£€æŸ¥ç½‘ç»œç¨³å®šæ€§
  - ç¡®ä¿ä¿æ´» ping æ­£å¸¸å·¥ä½œï¼ˆæ¯ 30 ç§’ä¸€æ¬¡ï¼‰
  - ç›‘æ§æœåŠ¡å™¨ç«¯é€Ÿç‡é™åˆ¶
</Accordion>

## æœ€ä½³å®è·µ

<Note>
**ç”Ÿäº§å°±ç»ªæ£€æŸ¥æ¸…å•ï¼š**

- âœ… ä¸ºé‡æ–°è¿æ¥å®ç°æŒ‡æ•°é€€é¿
- âœ… æ¯ 30 ç§’ä½¿ç”¨ä¿æ´» ping
- âœ… å¤„ç†æ‰€æœ‰æµäº‹ä»¶ï¼ˆæ•°æ®ã€é”™è¯¯ã€ç»“æŸã€å…³é—­ï¼‰
- âœ… å¼‚æ­¥å¤„ç†æ•°æ®ä»¥é¿å…é˜»å¡
- âœ… ç›‘æ§è¿æ¥å¥åº·çŠ¶å†µå¹¶åœ¨æ•…éšœæ—¶å‘å‡ºè­¦æŠ¥
- âœ… æ ¹æ®æ‚¨çš„ç”¨ä¾‹ä½¿ç”¨é€‚å½“çš„æ‰¿è¯ºçº§åˆ«
- âœ… å°½å¯èƒ½å…·ä½“åœ°è¿‡æ»¤æ•°æ®ä»¥å‡å°‘å¸¦å®½
</Note>

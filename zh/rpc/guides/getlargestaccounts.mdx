---
title: 如何使用 getLargestAccounts
sidebarTitle: getLargestAccounts
description: 了解 getLargestAccounts 的使用案例、代码示例、请求参数、响应结构和提示。
---

[`getLargestAccounts`](https://www.helius.dev/docs/api-reference/rpc/http/getlargestaccounts) RPC 方法返回 Solana 网络上按 lamport 余额排名的前 20 个账户的列表。此方法可用于网络分析、了解财富分布或识别 SOL 的重要持有者。

请注意，此方法的结果可能会被 RPC 节点缓存长达两个小时。

## 常见用例

*   **网络健康监测：** 观察 SOL 在最大账户中的集中情况。
*   **经济分析：** 研究 Solana 网络上的财富分布。
*   **识别大户：** 找到持有大量 SOL 的账户。

## 请求参数

此方法可以选择性地接受一个包含以下参数的配置对象：

* **`commitment`** (字符串，可选)：指定查询分类帐时使用的[承诺级别](https://www.helius.dev/blog/solana-commitment-levels)。如果未提供，则使用节点的默认承诺级别。
* **`filter`** (字符串，可选)：按账户类型过滤结果。接受的值有：
 * `circulating`：返回属于流通供应的最大账户。
 * `nonCirculating`：返回不属于流通供应的最大账户（例如，锁定账户、基金会账户）。
 如果省略，则在没有此特定过滤器的情况下考虑所有账户。

## 响应结构

JSON-RPC 响应的 `result` 字段将是一个 `RpcResponse` 对象。此对象中的 `value` 字段是一个包含最多 20 个账户对象的数组，每个对象包含：

* **`address`** (字符串)：账户的 base-58 编码公钥。
* **`lamports`** (u64)：账户的 lamports 余额。

响应还包括一个 `context` 对象，其中包含检索信息时的 `slot`。

## 示例

### 1. 获取前20个最大账户（无过滤器）

此示例获取按 lamport 余额排序的前20个最大账户，不使用任何供应过滤器。

<CodeGroup>

```bash cURL
# Replace <api-key> with your Helius API key
curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
  '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getLargestAccounts"
  }'
```

```javascript JavaScript (using @solana/web3.js)
// Replace <api-key> with your Helius API key
const { Connection } = require('@solana/web3.js');

async function logLargestAccounts() {
  const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
  try {
    const largestAccounts = await connection.getLargestAccounts();
    console.log(`Largest Accounts (Slot: ${largestAccounts.context.slot}):`);
    largestAccounts.value.forEach((account, index) => {
      console.log(
        `  ${index + 1}. Address: ${account.address}, Balance: ${account.lamports / 10**9} SOL`
      );
    });
    // For full raw details:
    // console.log(JSON.stringify(largestAccounts, null, 2));
  } catch (error) {
    console.error('Error fetching largest accounts:', error);
  }
}

logLargestAccounts();
```

</CodeGroup>

### 2. 获取前20个最大流通账户

此示例获取被视为流通供应部分的前20个最大账户。

<CodeGroup>

```bash cURL
# Replace <api-key> with your Helius API key
curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
  '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getLargestAccounts",
    "params": [{ "filter": "circulating" }]
  }'
```

```javascript JavaScript (using @solana/web3.js)
// Replace <api-key> with your Helius API key
const { Connection } = require('@solana/web3.js');

async function logLargestCirculatingAccounts() {
  const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
  try {
    const largestAccounts = await connection.getLargestAccounts({ filter: 'circulating' });
    console.log(`Largest Circulating Accounts (Slot: ${largestAccounts.context.slot}):`);
    largestAccounts.value.forEach((account, index) => {
      console.log(
        `  ${index + 1}. Address: ${account.address}, Balance: ${account.lamports / 10**9} SOL`
      );
    });
    // console.log(JSON.stringify(largestAccounts, null, 2));
  } catch (error) {
    console.error('Error fetching largest circulating accounts:', error);
  }
}

logLargestCirculatingAccounts();
```

</CodeGroup>

## 开发者提示

* **缓存数据：** RPC 节点可以缓存结果长达两个小时。这意味着数据可能不是最新区块的实时数据。
* **仅限前 20 名：** 此方法仅返回前 20 个账户。对于更全面的财富分布分析，可能需要其他数据来源或方法。
* **过滤器行为：** `circulating` 和 `nonCirculating` 过滤器取决于 RPC 节点对这些分类的定义和数据来源。

本指南提供了使用 `getLargestAccounts` RPC 方法查询 Solana 网络上最大 SOL 持有者所需的信息。
---
title: 如何使用 getAccountInfo
sidebarTitle: getAccountInfo
description: 了解 getAccountInfo 的使用案例、代码示例、请求参数、响应结构和提示。
---

[`getAccountInfo`](https://www.helius.dev/docs/api-reference/rpc/http/getaccountinfo) RPC 方法是查询 Solana 区块链的基本工具。它允许您检索与特定账户公钥相关的所有存储信息。这包括账户的 lamport 余额、拥有它的程序、是否可执行及其存储的数据。

## 常见用例

*   **检查 SOL 余额：** 确定任何账户的本机 SOL 余额。
*   **验证账户存在性：** 检查具有给定公钥的账户是否已初始化（即，是否有 lamports 或数据）。
*   **检查程序账户：** 检索由程序拥有的账户中存储的数据，这对于理解程序的状态至关重要。
*   **识别账户所有者：** 找出哪个程序是账户的所有者。这有助于确定如何解释账户的数据或它是否是系统拥有的账户。
*   **检查账户是否可执行：** 确定账户是否包含已部署的程序。

## 参数

1. `publicKey` (字符串，必需)：要查询的账户的 base-58 编码公钥。

2. `config` (对象，可选)：具有以下字段的配置对象：
 * `commitment` (字符串，可选)：指定用于查询的[承诺级别](https://www.helius.dev/blog/solana-commitment-levels)。默认为 `finalized`。
 * `finalized`：节点将查询由集群的绝大多数确认已达到最大锁定的最新区块。
 * `confirmed`：节点将查询由集群的绝大多数投票的最新区块。
 * `processed`：节点将查询其最新区块。请注意，该区块可能不完整。
 * `encoding` (字符串，可选)：账户数据的编码。默认为 `base64`。
 * `base58` (慢)
 * `base64`
 * `base64+zstd` (如果数据被压缩)
 * `jsonParsed`：如果账户数据是已知的程序状态（例如，代币账户、质押账户），节点将尝试将其解析为 JSON 结构。对于通用程序账户，通常会回退到二进制（base64）。
 * `dataSlice` (对象，可选)：将返回的账户数据限制为特定的切片。仅适用于 `base58`、`base64` 或 `base64+zstd` 编码。
 * `offset` (数字)：从账户数据开始的字节数以开始切片。
 * `length` (数字)：要返回的字节数。
 * `minContextSlot` (数字，可选)：请求可以评估的最小槽位。

## 响应

如果找到该账户，`result` 字段将包含一个具有两个主要属性的对象：

*   `context` (object): 包含有关请求的元数据。
    *   `slot` (number): 检索信息的插槽。
    *   `apiVersion` (string, optional): RPC API 版本。

*   `value` (object | null): 如果账户不存在，这将是 `null`。否则，它是一个包含以下内容的对象：
    *   `lamports` (number): 账户拥有的 lamports 数量（1 SOL = 1,000,000,000 lamports）。
    *   `owner` (string): 拥有此账户的程序的 base-58 编码公钥。
    *   `data` (array | object | string): 存储在账户中的数据。格式取决于请求中使用的 `encoding` 参数。
        *   对于 `base64`（默认），`base58`, `base64+zstd`：这通常是一个数组 `[encoded_string, encoding_format]`，例如，`["string_data", "base64"]`。
        *   对于 `jsonParsed`：如果数据可以被 RPC 节点解析（例如，对于 SPL Token 账户），这可以是一个 JSON 对象。否则，如果数据未被识别为标准布局，可能会默认为 `["", "base64"]` 或类似内容。
    *   `executable` (boolean): 如果账户包含程序，则为 `true`，否则为 `false`。
    *   `rentEpoch` (number): 下一个账户将欠租的纪元。
    *   `space` (number, optional): 数据的字节长度。（注意：官方 Solana 文档列出 `space`，而一些 RPC 提供商可能会包含它。它表示为账户数据分配的总空间）。有关 [账户数据和反序列化](https://www.helius.dev/blog/solana-dev-101-deserializing-account-data-on-solana) 的更多详细信息，请参阅我们的详细指南。

如果未找到账户，结果中的 `value` 字段将为 `null`。

## 示例：获取账户信息

让我们在主网上获取 Serum Program V3 ID (`9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin`) 的信息。

**注意：** 在下面的示例中，将 `YOUR_API_KEY` 替换为您实际的 Helius API 密钥。

<CodeGroup>

```bash curl
curl https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY -X POST -H "Content-Type: application/json" -d \
'{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getAccountInfo",
  "params": [
    "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin",
    {
      "encoding": "jsonParsed"
    }
  ]
}'
```

```javascript JavaScript (using @solana/web3.js)
const { Connection, PublicKey } = require('@solana/web3.js');

async function getAccountDetails() {
  const rpcUrl = 'https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY'; // Replace YOUR_API_KEY
  const connection = new Connection(rpcUrl, 'confirmed');
  const accountPubKey = new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin');

  try {
    const accountInfo = await connection.getAccountInfo(accountPubKey);

    if (accountInfo === null) {
      console.log('Account not found.');
      return;
    }

    console.log('Account Info:');
    console.log(`   Lamports: ${accountInfo.lamports}`);
    console.log(`   Owner: ${accountInfo.owner.toBase58()}`);
    console.log(`   Executable: ${accountInfo.executable}`);
    console.log(`   Rent Epoch: ${accountInfo.rentEpoch}`);
    // Data is a Buffer, you might need to deserialize it based on the account type
    // console.log(`   Data: ${accountInfo.data.toString()}`); 
  } catch (error) {
    console.error('Error fetching account info:', error);
  }
}

getAccountDetails();
```

```typescript Kit
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY";
const rpc = createSolanaRpc(rpc_url);

const publicKey = address("vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg");
const accountInfo = await rpc.getAccountInfo(publicKey).send();

console.log("Account Info:", accountInfo);
```

```rust Rust
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey::Pubkey};
use anyhow::Result;
use std::str::FromStr;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY"),
        CommitmentConfig::confirmed()
    );
    let pubkey = Pubkey::from_str("vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg")?;
    let account = client.get_account(&pubkey).await?;

    println!("{:#?}", account);

    Ok(())
}
```

</CodeGroup> 

## 开发者提示

*   **性能：** 对于需要频繁检查多个账户的应用程序，考虑使用 `getMultipleAccounts` 来批量请求并减少往返次数。
*   **数据反序列化：** `data` 字段通常需要根据拥有程序的数据结构进行反序列化。通常需要特定于程序的工具和库（例如，用于代币账户的 SPL Token 库）。我们关于[反序列化账户数据](https://www.helius.dev/blog/solana-dev-101-deserializing-account-data-on-solana)的博客文章提供了有用的技术和示例。
*   **速率限制：** 注意 RPC 节点的速率限制，特别是在查询大量账户或频繁请求时。
*   **成本管理：** `getAccountInfo` 通常是低成本查询，但频繁轮询可能会累积。优化您的查询模式。
*   **明智使用 `jsonParsed`：** 虽然 `jsonParsed` 可能很方便，但它可能不支持所有账户类型，并且如果程序更新其数据结构，其输出可能会更改。对于关键应用程序，使用已知布局解析二进制数据提供了更高的稳定性。
*   **考虑使用 `dataSlice`：** 如果您只需要账户数据的一小部分，请使用 `dataSlice` 来减少传输的数据量，并可能降低查询成本。
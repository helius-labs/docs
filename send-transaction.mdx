---
title: 'Sending Transactions on Solana'
description: 'Optimize your transactions to minimize confirmation latency and maximize delivery rates'
---

# Sending Transactions on Solana

Optimize your transactions to minimize confirmation latency and maximize delivery rates.

## Summary

We recommend the following best practices to help you land transactions:

* Use staked connections available with Helius
* Use commitment "processed" or "confirmed" to fetch the latest blockhash
* Add priority fees and optimize compute unit (CU) usage
* Set `maxRetries` to 0 and implement robust retry logic 
* Send with `skipPreflight` set to true (optional)

## Recommended Optimizations for Traders

We recommend the following optimizations for latency-sensitive traders. **You must already be applying the best practices for sending transactions mentioned above.**

1. Send transactions from Eastern US or Western Europe.
   * Choose Frankfurt or Pittsburgh if you want to co-locate with Helius transaction-sending servers.
   * Avoid sending regions far away from the validator network (e.g. LATAM or South Africa).

2. Warm the Helius regional caches to minimize tail latency.
   * Send a `getHealth` call every second using the same endpoint & API key you use for sending transactions.
   * Only one warming thread is required per region. Any more will have zero benefit.

## Staked Connections

### Shared Staked Endpoint (default)
* **Requirements:**
  * Priority fees meet or exceed the `recommended` value provided by the Priority Fee API
  * Set `maxRetries` to 0
* **Endpoint:** `https://mainnet.helius-rpc.com/?api-key=xxx`
* **Cost:** 1 credit per request
* **Tips:**
  * Check if you're getting staked connections by logging the `X-Helius-ConnectionType` response header. The value will be `regular` or `staked`.

### Dedicated Staked Endpoint
* Recommended for top traders or teams who want guaranteed access to staked connections, even during market congestion
* Transactions will be sent over staked connections via an optimized network (Asia, Europe, and North America), minimizing latency and confirmation times.
* **Endpoint:** `https://staked.helius-rpc.com?api-key=xxx`
* **Cost:** 50 credits per request.

## Sending Smart Transactions

At the most basic level, users must supply their keypair and the instructions they wish to execute, and we handle the rest.

We:
* Fetch the latest blockhash
* Build the initial transaction
* Simulate the initial transaction to fetch the compute units consumed
* Set the compute unit limit to the compute units consumed in the previous step, with some margin
* Set the priority fee (microlamports per compute unit)

### Node.js SDK

The `sendSmartTransaction` method is available in our Helius SDK for Node.js. To update to a more recent version of the SDK, run `npm update helius-sdk`.

```javascript
import { Helius } from 'helius-sdk';

const helius = new Helius('your-api-key');

const sendOptions = {
  skipPreflight: true, // Optional
  maxRetries: 0, // Recommended
};

// Instructions is an array of TransactionInstructions
// Signers is an array of Keypairs to sign the transaction
// lookupTables is an optional array of lookup tables
const txid = await helius.rpc.sendSmartTransaction(
  instructions,
  signers, 
  lookupTables, 
  sendOptions
);
```

### Rust SDK

The `send_smart_transaction` method is available in our Rust SDK. To update to a more recent version of the SDK, run `cargo update helius`.

```rust
use helius::rpc::JsonRpcClient;
use helius_sdk::Helius;

// Initialize the Helius client with your API key
let helius = Helius::new("your-api-key".to_string());

// Create your transaction instructions, signers, etc...

// Send the smart transaction
let signature = helius.rpc.send_smart_transaction(
    instructions,
    signers,
    lookup_tables, // Optional
    send_options,  // Optional
).await?;
```

## Sending Transactions Without the SDK

We recommend sending smart transactions with one of our SDKs, but the same functionality can be achieved without using one.

### Prepare and Build the Initial Transaction

First, create a versioned transaction with your desired instructions.

```javascript
const initialTransaction = new VersionedTransaction(
  new TransactionMessage({
    instructions: instructions,
    payerKey: payer,
    recentBlockhash: (await connection.getLatestBlockhash('confirmed')).blockhash,
  }).compileToV0Message(lookupTables)
);
```

### Optimize the Transaction's Compute Unit (CU) Usage

It's recommended to use a test transaction with the desired instructions first, plus an instruction that sets the compute limit to 1.4m CUs. This is done to ensure the transaction simulation succeeds.

```javascript
const testInstructions = [
  ComputeBudgetProgram.setComputeUnitLimit({ units: 1_400_000 }),
  ...instructions,
];

const testTransaction = new VersionedTransaction(
  new TransactionMessage({
    instructions: testInstructions,
    payerKey: payer,
    recentBlockhash: (await connection.getLatestBlockhash()).blockhash,
  }).compileToV0Message(lookupTables)
);

const rpcResponse = await connection.simulateTransaction(testTransaction, {
  replaceRecentBlockhash: true,
  sigVerify: false,
});

const unitsConsumed = rpcResponse.value.unitsConsumed;
```

Add a margin to ensure the transaction executes without issues:

```javascript
let customersCU = Math.ceil(unitsConsumed * 1.1);

const computeUnitIx = ComputeBudgetProgram.setComputeUnitLimit({
  units: customersCU
});

instructions.push(computeUnitIx);
```

### Serialize and Encode the Transaction

```javascript
const serializedTransaction = bs58.encode(transaction.serialize());
```

### Setting the Right Priority Fee

```javascript
const response = await fetch(HeliusURL, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    jsonrpc: "2.0",
    id: "1",
    method: "getPriorityFeeEstimate",
    params: [
      {
        transaction: bs58.encode(versionedTransaction), // Pass the serialized transaction in
        options: { recommended: true },
      },
    ],   
  }),
});

const data = await response.json();
const priorityFeeRecommendation = data.result.priorityFeeEstimate;

const computeBudgetIx = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: priorityFeeRecommendation,
});

instructions.push(computeBudgetIx);
```

### Build and Send the Optimized Transaction

Now, build a new transaction with the updated instructions that include compute unit limit and price settings:

```javascript
const finalTransaction = new VersionedTransaction(
  new TransactionMessage({
    instructions: instructions, // Now includes compute limit and price instructions
    payerKey: payer,
    recentBlockhash: (await connection.getLatestBlockhash('confirmed')).blockhash,
  }).compileToV0Message(lookupTables)
);

// Sign the transaction
for (const signer of signers) {
  finalTransaction.sign([signer]);
}

// Send the transaction
const signature = await connection.sendRawTransaction(
  finalTransaction.serialize(),
  { skipPreflight: true, maxRetries: 0 }
);
```

### Polling the Transaction's Status and Rebroadcasting

While staked connections will forward a transaction directly to the leader, it is still possible for the transaction to be dropped in the Banking Stage. It is recommended that users employ their own rebroadcasting logic rather than rely on the RPC to retry the transaction for them.

```javascript
async function pollTransactionConfirmation(connection, txSig) {
  // 15 second timeout
  const timeout = 15000;
  // 5 second retry interval
  const interval = 5000;
  let elapsed = 0;

  return new Promise((resolve, reject) => {
    const intervalId = setInterval(async () => {
      elapsed += interval;

      if (elapsed >= timeout) {
        clearInterval(intervalId);
        reject(new Error(`Transaction ${txSig}'s confirmation timed out`));
      }

      const status = await connection.getSignatureStatuses([txSig]);

      if (status?.value[0]?.confirmationStatus === "confirmed") {
        clearInterval(intervalId);
        resolve(txSig);
      }
    }, interval);
  });
}
```

With Helius's staked connections and optimized transaction sending process, you can maximize your transaction confirmation rates and minimize latency on the Solana blockchain. 
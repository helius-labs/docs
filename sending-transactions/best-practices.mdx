---
title: 'Best Practices'
description: 'This guide covers recommended practices for sending transactions on Solana using Helius to maximize confirmation rates and minimize latency.'
---

## Core Recommendations

Follow these core recommendations for any transaction on Solana:

### 1. Use Staked Connections

- Use [Staked Connections](/sending-transactions/staked-connections) when possible to bypass network congestion
- Enable staked connections by meeting priority fee recommendations and setting `maxRetries: 0`
- For guaranteed access, use the dedicated staked endpoint

### 2. Use the Right Commitment Level

- Use commitment level `processed` or `confirmed` when fetching the latest blockhash
- This ensures you get the most up-to-date blockhash for your transaction

```javascript
// Example of fetching blockhash with correct commitment
const { blockhash, lastValidBlockHeight } = 
  await connection.getLatestBlockhash('confirmed');
```

### 3. Add Appropriate Priority Fees

- Always include priority fees, especially during network congestion
- Use the [Priority Fee API](https://docs.helius.dev/solana-apis/priority-fee-api) to get dynamic fee recommendations

```javascript
// Add priority fee instruction
const priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: priorityFeeEstimate
});
instructions.push(priorityFeeIx);
```

### 4. Optimize Compute Unit Usage

- Set appropriate compute unit limits based on transaction simulation
- Add a safety margin (typically 10%) to avoid compute limit errors

```javascript
// Simulate to get compute units consumed
const simulation = await connection.simulateTransaction(testTransaction);
const unitsConsumed = simulation.value.unitsConsumed;

// Set compute units with margin
const computeUnitLimit = Math.ceil(unitsConsumed * 1.1);
const computeUnitIx = ComputeBudgetProgram.setComputeUnitLimit({
  units: computeUnitLimit
});
instructions.push(computeUnitIx);
```

### 5. Implement Custom Retry Logic

- Set `maxRetries: 0` to disable automatic retries from the RPC
- Implement your own retry logic to have better control over rebroadcasting
- Only retry if the transaction hasn't been confirmed (check signature status)
- Only re-sign a transaction when the blockhash becomes invalid

```javascript
// Example retry logic
const sendAndConfirmWithRetry = async (transaction, signers, connection) => {
  // Sign the transaction
  transaction.sign(signers);
  
  // Send the transaction with maxRetries: 0
  const signature = await connection.sendRawTransaction(
    transaction.serialize(),
    { skipPreflight: true, maxRetries: 0 }
  );
  
  // Implement custom polling and retry logic
  let confirmed = false;
  const startTime = Date.now();
  
  while (!confirmed && Date.now() - startTime < 60000) {
    try {
      const status = await connection.getSignatureStatus(signature);
      
      if (status?.value?.confirmationStatus === 'confirmed') {
        confirmed = true;
        return signature;
      }
      
      // Wait before checking again
      await new Promise(resolve => setTimeout(resolve, 2000));
    } catch (error) {
      console.warn(`Error checking status: ${error}`);
    }
  }
  
  // Transaction not confirmed within timeout, check if blockhash still valid
  const isValid = await connection.isBlockhashValid(
    transaction.recentBlockhash,
    'confirmed'
  );
  
  if (!isValid) {
    // Blockhash expired, create new transaction with new blockhash
    return sendTransactionWithNewBlockhash();
  } else {
    // Blockhash still valid, rebroadcast the same transaction
    return connection.sendRawTransaction(
      transaction.serialize(),
      { skipPreflight: true, maxRetries: 0 }
    );
  }
};
```

### 6. Consider Skipping Preflight Checks

- Set `skipPreflight: true` to bypass client-side simulation before sending
- This can speed up transaction submission, especially for latency-sensitive applications
- Only use when you're confident your transactions are well-formed

## Advanced Optimizations for Traders

For latency-sensitive traders, consider these additional optimizations:

### 1. Regional Optimization

- Send transactions from Eastern US or Western Europe for lowest latency
- Frankfurt or Pittsburgh provide optimal co-location with Helius servers
- Avoid sending from regions far from the validator network (LATAM, South Africa)

### 2. Cache Warming

- Send a `getHealth` call every second using the same endpoint & API key 
- This warms the Helius regional caches to minimize tail latency
- Only one warming thread is required per region

```javascript
// Cache warming example
setInterval(async () => {
  try {
    await fetch('https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: '1',
        method: 'getHealth'
      })
    });
  } catch (error) {
    // Ignore errors
  }
}, 1000);
```

### 3. Use Smart Transactions

- Use [Smart Transactions](/sending-transactions/smart-transactions) to automatically apply best practices
- Smart Transactions handle blockhash management, compute unit optimization, and priority fees
- Available through the Helius SDK for both Node.js and Rust

## Common Pitfalls to Avoid

1. **Using stale blockhashes** - Always fetch a fresh blockhash for each transaction attempt
2. **Insufficient priority fees** - Network congestion may require higher fees than expected
3. **Incorrect compute limits** - Setting too low can cause failure, too high wastes SOL
4. **Excessive automatic retries** - Can lead to duplicated transactions and wasted fees
5. **Ignoring transaction status** - Always check confirmation status before retrying
